import React, { useEffect, useState } from 'react';
import { GameClient } from '../api/client';

export default function QueuePanel({ queue = [], onRefresh, onItemClick, parentAreaId = null }) {
  const [secondsMap, setSecondsMap] = useState({});

  const parseSeconds = (v) => {
    if (v == null) return null;
    if (typeof v === 'number') return Math.max(0, Math.floor(v));
    if (typeof v === 'string') {
      const m = v.match(/(\d+)/);
      if (m) return parseInt(m[1], 10);
    }
    return null;
  };

  useEffect(() => {
    // Initialize seconds map from incoming queue
    const next = {};
    (queue || []).forEach((item, idx) => {
      const key = `${item.areaId || item.areaName || ''}:${item.type}:${item.id || item.name}:${idx}`;
      // look for common time fields
      const secs = parseSeconds(item.secondsRemaining) ?? parseSeconds(item.timeRemainingSeconds) ?? parseSeconds(item.timeRemaining) ?? parseSeconds(item.seconds);
      next[key] = secs;
    });
    setSecondsMap(next);
  }, [queue]);

  useEffect(() => {
    const id = setInterval(() => {
      setSecondsMap(prev => {
        const next = { ...prev };
        let changed = false;
        Object.keys(next).forEach(k => {
          if (next[k] == null) return;
          if (next[k] > 0) { next[k] = next[k] - 1; changed = true; }
        });
        return changed ? next : prev;
      });
    }, 1000);
    return () => clearInterval(id);
  }, []);

  // When an item reaches 0 seconds or 100% progress, trigger a single refresh to sync with server
  useEffect(() => {
    if (!onRefresh) return;
    let triggered = false;
    (queue || []).forEach((item, idx) => {
      const key = `${item.areaId || item.areaName || ''}:${item.type}:${item.id || item.name}:${idx}`;
      const secs = (typeof secondsMap[key] !== 'undefined' && secondsMap[key] !== null) ? secondsMap[key] : (parseSeconds(item.secondsRemaining) ?? parseSeconds(item.timeRemainingSeconds) ?? parseSeconds(item.timeRemaining) ?? parseSeconds(item.seconds));
      const prog = (typeof item.totalTime === 'number' && secs != null) ? Math.max(0, Math.min(100, Math.floor(((item.totalTime - secs) / item.totalTime) * 100))) : (item.progress || 0);
      if ((secs === 0 && secs !== null) || prog >= 100) {
        if (!triggered) {
          triggered = true;
          // schedule one refresh shortly to allow UI to show 100% briefly
          setTimeout(() => { try { onRefresh(); } catch (e) {} }, 800);
        }
      }
    });
  }, [secondsMap, queue, onRefresh]);

  const humanTime = (s) => {
    if (s == null) return 'Unknown';
    const sec = Math.max(0, Math.floor(s));
    const h = Math.floor(sec / 3600);
    const m = Math.floor((sec % 3600) / 60);
    const sRem = sec % 60;
    if (h > 0) return `${h}h ${m}m`;
    if (m > 0) return `${m}m ${sRem}s`;
    return `${sRem}s`;
  };

  return (
    <div className="panel" style={{ marginBottom: 12 }}>
      <div className="panel-header">Construction Queue</div>
      <div className="panel-body" style={{ padding: 12 }}>
        {(!queue || queue.length === 0) ? (
          <div style={{ color: 'var(--text-muted)' }}>Nothing is currently building.</div>
        ) : (
          <div style={{ display: 'flex', flexDirection: 'column', gap: 8 }}>
            { (queue || []).filter((item, idx) => {
                const key = `${item.areaId || item.areaName || ''}:${item.type}:${item.id || item.name}:${idx}`;
                const secs = (typeof secondsMap[key] !== 'undefined' && secondsMap[key] !== null) ? secondsMap[key] : (parseSeconds(item.secondsRemaining) ?? parseSeconds(item.timeRemainingSeconds) ?? parseSeconds(item.timeRemaining) ?? parseSeconds(item.seconds));
                const prog = (typeof item.totalTime === 'number' && secs != null) ? Math.max(0, Math.min(100, Math.floor(((item.totalTime - secs) / item.totalTime) * 100))) : (item.progress || 0);
                // hide items that reached 100% or have 0s remaining (they will be refreshed out)
                if ((secs === 0 && secs !== null) || prog >= 100) return false;
                return true;
              }).map((item, idx) => {
              const key = `${item.areaId || item.areaName || ''}:${item.type}:${item.id || item.name}:${idx}`;
              const secs = (typeof secondsMap[key] !== 'undefined' && secondsMap[key] !== null) ? secondsMap[key] : (parseSeconds(item.secondsRemaining) ?? parseSeconds(item.timeRemainingSeconds) ?? parseSeconds(item.timeRemaining) ?? parseSeconds(item.seconds));
              const prog = (typeof item.totalTime === 'number' && secs != null) ? Math.max(0, Math.min(100, Math.floor(((item.totalTime - secs) / item.totalTime) * 100))) : (item.progress || 0);
              return (
                <div
                  key={idx}
                  onClick={() => onItemClick && onItemClick(item)}
                  style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', gap: 12, cursor: onItemClick ? 'pointer' : 'default' }}
                >
                  <div style={{ display: 'flex', flexDirection: 'column' }}>
                    <div style={{ fontWeight: 700 }}>{item.name || item.id}{item.areaName ? ` — ${item.areaName}` : ''}</div>
                    <div style={{ fontSize: '0.85rem', color: 'var(--text-muted)' }}>{item.type} {item.count ? `— ${item.count}x` : ''} {secs != null ? `— ${humanTime(secs)} remaining` : ''}</div>
                  </div>
                  <div style={{ width: 180 }}>
                    <div className="progress-bar-bg" style={{ height: 10 }}>
                      <div className="progress-bar-fill" style={{ width: `${prog}%`, backgroundColor: 'var(--accent-green)', height: '100%' }} />
                    </div>
                    <div style={{ fontSize: '0.8rem', color: '#bbb', textAlign: 'right', marginTop: 6 }}>{prog}%</div>
                  </div>
                  <div style={{ display: 'flex', gap: 8, alignItems: 'center' }}>
                    {/* Show Cancel button only for queued Units (not on building cards) */}
                    {(item.type === 'Unit' || item.type === 'Building') && (
                      <button className="btn" onClick={async (e) => {
                        e.stopPropagation();
                        const areaId = item.areaId || parentAreaId || null;
                        if (!areaId) { alert('Area context required to cancel this item'); return; }
                        if (!confirm('Cancel queued item and refund remaining resources?')) return;
                        try {
                          const resp = await GameClient.cancelUpgrade(areaId, item.id || item.name, item.type);
                          if (resp && resp.success) {
                            if (typeof onRefresh === 'function') onRefresh();
                            alert('Cancelled. Resources refunded.');
                          } else {
                            alert((resp && resp.error) || 'Failed to cancel item');
                          }
                        } catch (err) {
                          console.error('Cancel queue item error', err);
                          alert(err && err.message ? err.message : 'Failed to cancel item');
                        }
                      }}>Cancel</button>
                    )}
                  </div>
                </div>
              );
            })}
          </div>
        )}
      </div>
      {/* footer removed: manual Refresh button removed per UX request */}
    </div>
  );
}
